HAK 2017-02 :

- on recupere l'archive lilasApp.zip sur le site Mitch, release officielle pour travailler at home.
- on en extrait appsfo.jar
- on dezippe appsfo.jar
	on trouve quatre RomMicrocode.mem
		- 1 avec jeux d'instr. complet
		- 3 identiques avec interrupt en plus
	on trouve UAL16bMD.lilas qui est la partie mul/div de l'alu avec les registres internes (cf plus loin "doute Aalu")

- on lance l'etape2 --> on obtient un RomMicrocode.mem semblable au petit ci-dessus, avec juste une diff = un BUG :
	@1d, "Saut si BG=0, @16" au lieu de "Saut si BG=0, @ici"

- microcode archive en 2015 :
	elle a le bug plus 3 differences

Doute Aalu :
la fonction 0x0E "Aalu <--> Y" est supposÃ©e faire un truc qui n'est pas compatible avec la figure de la doc.
le code UAL16bMD.lilas :
	aIn <=  with fct select (zero, y, 
                           a[14:0] & not F17, // div
			   F[0]&a[15:1],// mul
                           zero, zero, zero, x,
                           zero, zero, zero, zero, zero, zero, zero, zero);
indique que pour fct = 0x0E, aIn recevra y.
Ce "with .. select" est une sorte de switch ou les valeurs du selecteur sont appliquees dans l'ordre decroissant,
on retrouve bien x pour fct = 0x08 soit "Pâ†0, Aaluâ†X, Baluâ†Y"

-----------------------------------------------------------------------------------------------------------------
doc secrete du Cortex Mitch+ :
http://intranet-gei.insa-toulouse.fr:8181/Enseignements/SFO/MIC-3/Documents/gitSFOMIC3/APPSFOPROF/arch/
doc Lilas : wgot, seems Ok
http://intranet-gei.insa-toulouse.fr:8181/Git/gitLILASV4/LILASV4/doc/index.html

wget -nc -E -p -r -l9 -k http://intranet-gei.insa-toulouse.fr:8181/Git/gitLILASV4/LILASV4/doc/index.html
wget -nc -E -p -r -l12 -k http://intranet-gei.insa-toulouse.fr:8181/Enseignements/SFO/MIC-3/Documents/gitSFOMIC3/APPSFOPROF/index.html
la on a presque tout le site !
Capture meme l'archive d'installation LILASHOME aka lilasApp.zip de 10.8Mo

-----------------------------------------------------------------------------------------------------------------
AUDIO
- la frequ d'echantillonnage est imposee par le hardware SPI implante dans le FPGA
  le bit pretSPI commande l'interruption

- la PWM tourne en permanence deja quand on est en mode etape 1

			mesures :	theorie
- porteuse PWM	 	97.66 kHz	25/256 = 97.65625 kHz
- I2S bit clock BCK 	1.562 MHz	25/16 = 1.5625 (640ns)
- I2S frame clock LRCK	48.83 kHz	25/(16*16*2) = 48.828125 kHz (20.48us) c'est la Fs audio
- ADC clock SCKI	25 MHz
- demie Fs audio	24.42 kHz	24.4140625 kHz avec le prog audio_clock.ass qui toggle une LED
- freq pic filtre audio			256 * Fs = 190.7 Hz
- chrono 20 * 1<<16 Ts	26.6s		26,8435456s
-----------------------------------------------------------------------------------------------------------------
R.E. de l'assembleur
- il est base sur JavaCC et JJTree (on a 3 docs frenchy), bon JavaCC c'est le Yacc de java
- code source dans \DEZIP\appsfo\arch\assembleur
	17 fichiers java, presque tous Generated By:JavaCC:
	1 .jj et 1 .jjt "JJTree template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+"
  mais il n'y a pas les mnemos dans ce code source, sauf ORG, EQU et WORD
- il y a 2 classes dans \DEZIP\appsfo\assembleur qui pourraient bien contenir les opcodes,
  il y a aussi la table du jeu d'instructions en xml mais est-ce que c'est seult la doc ?? A TESTER
 
-----------------------------------------------------------------------------------------------------------------
R.E. du lilas principal du simulateur :
	\DEZIP\appsfo\arch\processeurComplet\ProcesseurComplet2015.lilas
- ce lilas est passe en premier argument pour toutes les simus et meme la nexys en remote
- il contient juste un <module>, contenant :
- une liste de signaux, in out et internal, meme format que le lilas HDL vu a l'etape 3 GPIO
- des instances, connectees explicitement,
  par exemple :
		<arch.coeur.CarteCoeur2a  name="carteCoeur"..... />
	  qui reference \DEZIP\appsfo\arch\coeur\CarteCoeur2a.lilas
	  dans le vhdl associe l'instance est :
		carteCoeur : arch_coeur_CarteCoeur2a
	  qui matche \DEZIP\appsfo\arch\coeur\CarteCoeur2a.vhd
  on trouve les instances des auttres "cartes" t.q. ROM, RAM, Audio, NVIC, etc...
- un element <code language="logic" durÃ©eActivation="1ns"> qui contient en CDATA du HDL concurrent
  a la maniere du lilas HDL vu a l'etape 3 GPIO. Ici il s'agit de la gestion du bus.
- des elements <awt name="fulano"> qui sont des blocs graphiques hierarchises, avec une hierarchie
  differente de celle du HDL.
  En particulier il y a plusieurs arbres possibles, qui sont choisis probablement via l'argument -awt=
  de la ligne de commande.
  Les chemins d'acces aux sous-blocs sont constitues de noms d'instances du HDL, termines par un nom
  d'awt. Les noms d'instance permettent de trouver le fichier source lilas correspondant, exemple :
	carteCoeur.coeur.coeurAWT.panMicroseq
	carteCoeur est une instance de arch.coeur.CarteCoeur2a, decrit dans \arch\coeur\CarteCoeur2a.lilas
	   coeur y est une instance de CoeurModifiable2a, cf CoeurModifiable2a.lilas
	      coeurAWT y est une instance de CoeurAWT2a, cf CoeurAWT2a.lilas
		 panMicroseq y est un awt, contenant une image arch.seqMicroProg.UniteSeqMicroProg2a
		    qu'on trouve dans \arch\seqMicroProg\UniteSeqMicroProg2a.svg
  Les awt contiennent des <ElementSVG idRef="valSelIndic" qui sont les elements animes ou editables du GUI.
  Par exemple ValSelIndic est un element <text> qui possede cet id sur l'image svg (c'est que du xml)
	<text
		x="2398.1099" y="6334.1987"
		id="valSelIndic"
		xml:space="preserve"
		style="font-size:159.3830719px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Times New Roman;-inkscape-font-specification:'Times New Roman,'"
		sodipodi:linespacing="125%">
			<tspan x="2398.1099" y="6334.1987" id="tspan3005">valSelIndic</tspan>
	</text>
   similairement les boules bleues ou rouges sont des elements <g qui sont des groupes (path + texte)
- les elements <script name="initEtape1"> contiennent un script qui est execute soit
	- action bouton
	- option -script dans la ligne de commande
  les scripts sont dans  ProcesseurComplet2015_tst.lilas qui est pris A LA PLACE de ProcesseurComplet2015.lilas
  si on met l'option -test dans la ligne de commande !!!
  
-----------------------------------------------------------------------------------------------------------------
Notes :
- Nommages
	- Les noms de modules Lilas sont les noms de fichiers lilas, un module pour 1 fichier
	- les noms d'entites vhdl generees reproduisent le pathname du fichier lilas, exemple
		entity arch_seqMicroProg_CtrDown
		genere d'apres \arch\seqMicroProg\CtrDown.lilas
	  
- AWT = Abstract Window Toolkit (AWT) est une bibliothèque graphique pour Java
  mais en fait c'est presque totalement masque par Lilas et SVG
	https://fr.wikipedia.org/wiki/Abstract_Window_Toolkit
	https://www.jmdoudoux.fr/java/dej/chap-awt.htm
	https://www.jmdoudoux.fr/java/dej/chap-awt-composants.htm

- SVG = Scalable Vector Graphics
  <!-- Created with Inkscape (http://www.inkscape.org/) --> 
  sodipodi est un ancetre d'inkscape

- extract
  les fichiers qu'on peut extraire avec -extract ont le suffixe _extract, c'est pour cela qu'ils sont
  differents de ceux qui sont charges automatiquement "par defaut"

- build par etapes
	-to=java (en fait il fait aussi les .class puis efface le .java)
	 question : fait-il deux .java par module (activation class et root class) ? oui
	-to=fpga fait un top module mydesign_boardName_fpga.lilas et un module de remote
	 debug mydesign_boardName_pc.lilas
	-to=vhdl (question : est-ce recursif ?)
	-to=bit
	-to=xml serait un template d'instanciation en Lilas (question : c'est ça ?)
	-to=tst : il fait un module de test (un testbench) mydesign_tst.lilas
	 ce module a une variable de config isRemoteExecution
  operations auxiliaires :
	-to=list
	-to=xml serait un template d'instanciation en Lilas (question : c'est ça ?)
  etc...

- options a tester :
	-cleanFull
	-show=java, -show=javaroot (activation class et root class)
	-force

- options connues
	-script=	les script sont dans le top module (normalement _tst)
	-awt=		les awt sont dans le top module, mais ils peuvent referencer awt d'un module en dessous
	-test : lance mydesign_tst.lilas avec isRemoteExecution=false
	-remote : builde le .bit puis lance mydesign_tst.lilas avec isRemoteExecution=true

- les 2 classes d'un module
	- mymodule.class : dite activation class (le code lilas comportemental fournit le corps de la
	  fonction d'activation)
	- mymodule_LILAS.class : la super class ou root class dont le constructeur cree les ports du module

- les modules qui ont plusieurs configurations (par exemple le _tst)
	mydesign_tst_0.class et mydesign_tst_1.class
	mydesign_tst_0_LILAS.class et mydesign_tst_1_LILAS.class
	mydesign_tst_LILAS.class et mydesign_tst_LILAS$1.class et mydesign_tst_LILAS$2.class (pourquoi ?)

- file path
  comment lilas sait-il ou trouver /arch/processeurComplet/ProcesseurComplet2015.lilas ?
  sans doute grace a lilasConfig.xml qui fait reference a
	LILASHOME/lib
	~/APPSFO
  cependant arch n'est pas dans LILASHOME/lib mais dans LILASHOME/lib/appsfo.jar
	<?xml version="1.0" encoding="UTF-8"?><config>
	<jar path="/home/commetud/3eme Annee MIC/APPSFO/LILASHOME/lib"/>
	<var name="javaLibraryPath" value="/home/commetud/3eme Annee MIC/APPSFO/LILASHOME/lib"/>
	<var name="dirSrc" value="/home_pers/noullet/APPSFO"/>
	<var name="logLevel" value="SEVERE"/>
	<var name="nexys3LoadCmd" value="lilas"/>
	<var name="ftdiJava" value="ftdi"/>
	</config>
   d'ou les experiences a faire :
	- demander un .lilas inexistant, pour voir s'il dit ou il a cherche : IL DIT PAS
	- utiliser l'option to=list : MARCHE PO si cela vient d'un jar, mais OK si tout vient d'un arbre a plat
	- renommer appsfo.jar, puisque son nom n'est mentionne nulle part, pour confirmer qu'il cherche
	  dans tous les jars : OUI IL LE FAIT
	- essayer de refaire un appsfo.jar en zippant le contenu : MARCHE PLUS OU MOINS
	- essayer avec le contenu a plat : NON, TROUVE RIEN si on met dans LILASHOME/lib
	  OK si on met le contenu de appsfo.jar (arch, etape1, etc...) dans APPSFO
	- modifier un .lilas :
		mode jar : MODIF PAS PRISE, il utilise la version .class
		mode flat : GROS PLANTUS
	- idem, en supprimant la .class : ECHOUE au lieu de recompiler - hyp : le jar est en read-only

- zip sous linux
	zip -r monzip.zip truc chose	<-- -r pour recursif, indispensabeul
	zip ~/ailleurs/monzip.zip truc/chose/bidule.png	<-- ajoute ou remplace bidule (il faut etre dans le dir de truc)
	zip -d ~/ailleurs/monzip.zip truc/chose/bidule.png	<-- supprime bidule
	rm -r arch; unzip -u ~/ailleurs/monzip.zip arch <-- refresh la branche arch
-----------------------------------------------------------------------------------------------------------------
Ant et Eclipse
www.vogella.com/tutorials/ApacheAnt/article.html
https://www.tutorialspoint.com/ant/ant_eclipse_integration.htm
http://barlatier.developpez.com/eclipse/tutorial/ant/
http://www.jmdoudoux.fr/java/dejae/indexavecframes.htm
https://www.jmdoudoux.fr/java/dejae/chap010.htm
http://www.jmdoudoux.fr/accueil.html
http://help.eclipse.org/neon/index.jsp?topic=%2Forg.eclipse.platform.doc.user%2FgettingStarted%2Fqs-81_basics.htm
--------------------------------------------------------------------------------------------------
typical problems sur CentOS :

aléatoire :
*** SEVERE from lilas.base.Port.postActivation:91 : Error Port, it is impossible to postActivate
 for variable valIn associated to signal /instanceVariable/circuit/carteBus/InDA in module arch.bus.ConnexionET
 (/instanceVariable/circuit/carteBus/ib/DAET) :
 java.lang.IllegalStateException: RunnableQueue not started or has exited
   ** lilas.base.Port.postActivation:91
   ** lilas.base.Module.postActivation:802
   ** lilas.base.SystemL.changerDateEtPostActiver:390
   ** lilas.base.SystemL.access$0:379
   ** lilas.base.SystemL$1.run:276
-----------------

Fatal, en cas de modif
Warning, module not compiled : arch.coeur.CoeurAWT2a
Warning, module not compiled : lilas.bib.nexys3.ClkDivisor
Warning, module not compiled : arch.ual2a.UAL16bMD
Warning, module not compiled : arch.cdd.MemoireRegistres
- on a eu ce pb sur Ubuntu Frison, workaround : dezipper tous les jars (appsfo et lilasV4)

[jln@localhost APPSFO]$ java -version
openjdk version "1.8.0_121"
OpenJDK Runtime Environment (build 1.8.0_121-b13)
OpenJDK Server VM (build 25.121-b13, mixed mode)
[jln@localhost APPSFO]$ javac -version
javac 1.8.0_121

noullet@srv-ens4:~$ java -version
java version "1.7.0_45"
Java(TM) SE Runtime Environment (build 1.7.0_45-b18)
Java HotSpot(TM) 64-Bit Server VM (build 24.45-b08, mixed mode)

yum list installed | grep java
yum search java | grep 'java-'

yum install java-1.8.0-openjdk-devel
--------------------------------------------------------------------------------------------------
Typical problem sur Ubuntu (INSA et Frison) :

Warning : bootstrap class path not set in conjunction with -source 1.7
suivi d'un bloquage sur abstract class

http://stackoverflow.com/questions/3091040/why-do-we-use-rt-jar-in-a-java-project?noredirect=1&lq=1

exemple de commande (on est suppose entre en 1.8) :
javac -source 1.7 -bootclasspath /usr/lib/jvm/java-7-oracle/jre/lib/rt.jar Main.java
Si on ne met pas -bootclasspath on a le warning, et de bons ennuis futurs a l'utilisation

Hyp 1 : bootclasspath est memorise dans la classe compilee
Hyp 2 : Mitch a compile Ok mais quand c'est Lilas qui compile il ne met pas l'option -bootclasspath
et ce n'est pas le bon rt.jar qui est choisi

https://docs.oracle.com/javase/8/docs/technotes/tools/findingclasses.html
